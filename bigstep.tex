\chapter{Semantica operazionale ``big-step''}
\marginpar{Mancino}

In questo capitolo introduciamo la semantica operazionale \emph{big-step}
(letteralmente ``a grandi passi''),
un particolare tipo di semantica operazionale che descrive formalmente
come il risultato complessivo dell'esecuzione di un'operazione è ottenuto.
Per fare questo, sfrutta schemi di assiomi e regole che vengono presentati
come
\[
\rulename{nome regola}
\prooftree
  \textrm{premessa}_1
  \quad\cdots\quad
  \textrm{premessa}_k
\justifies
  \textrm{conclusione}
\using
  (\textrm{side condition})
\endprooftree
\]
La semantica di questa scrittura è che la congiunzione logica di
`$\textrm{premessa}_1$', \dots, `$\textrm{premessa}_k$' implica
`$\textrm{conclusione}$' a patto che valga `$\textrm{side condition}$'.

\section{Un primo esempio di semantica big-step}\marginpar{Mancino}
\label{sec:primo-esempio-semantica-big-step}
Consideriamo il frammento di WHILE con la seguente sintassi:
\[
  \AExp \ni E ::= n \vbar E+E
\]
dove $n \in \Integer$.
Una possibile semantica big-step di questo frammento è data
dai seguenti schemi:

\[
\rulename{B-NUM}
\prooftree
  \nohyp
\justifies
  n \Downarrow n
\endprooftree
\qquad
\rulename{B-ADD}
\prooftree
  E_1 \Downarrow n_1 \quad E_2 \Downarrow n_2
\justifies
  (E_1 + E_2) \Downarrow n_3
\using
  n_3 = n_1 + n_2
\endprooftree
\]

L'operatore $\Downarrow$ può essere letto come ``valuta a'' e permette
in un solo colpo di compiere tutti i passi affinché un comando o un'espressione
giunga al termine della propria computazione.

Le definizioni semantiche date sono dette ``schemi'' perché vanno
opportunamente instanziate. Vediamone alcuni esempi; la seguente è
un'istanza corretta della B-NUM:

\[
\rulename{B-NUM}
\prooftree
  \nohyp
\justifies
  3 \Downarrow 3
\endprooftree
\]

La seguente è invece un'istanza corretta della B-ADD:

\[
\rulename{B-ADD}
\prooftree
  \rulename{B-NUM}
  \prooftree
    \nohyp
  \justifies
     3 \Downarrow 3
  \endprooftree
  \quad
  \rulename{B-NUM}
  \prooftree
    \nohyp
  \justifies
     2 \Downarrow 2
  \endprooftree
\justifies
  (3+2) \Downarrow 5
\using
  5 = 3+2
\endprooftree
\]

La seguente è invece un'istanza scorretta (cioè non dimostrabile) della B-ADD:

\[
\rulename{B-ADD}
\prooftree
  3 \Downarrow 6
  \quad
  2 \Downarrow 4
\justifies
  (3+4) \Downarrow 10
\using
  10 = 6+4
\endprooftree
\]


Operando in questo modo, ci è possibile realizzare dimostrazioni ad albero
come la seguente:

$$
\prooftree
  \prooftree
   \justifies
     3 \Downarrow 3
  \endprooftree
  \quad
  \prooftree
	\prooftree
   	  \justifies
   		2 \Downarrow 2
	\endprooftree
	\quad
	\prooftree
   	  \justifies
   		1 \Downarrow 1
	\endprooftree
   	\justifies
   	  (2+1) \Downarrow 3
   	\using
   	  3 = 2+1
  \endprooftree
  \justifies
    (3+(2+1)) \Downarrow 6
   	\using
   	  6 = 3+(2+1)
\endprooftree
$$

La dimostrazione, come si vede, è un albero che va dal basso verso l'alto, dove
in fondo troviamo ciò che vogliamo dimostrare e, applicando le due regole date precedentemente,
giungiamo a degli assiomi (le foglie dell'albero) che quindi provano quanto volevamo.
In sostanza, per dimostrare la conclusione dobbiamo far valere tutte le premesse che ricaviamo
applicando le regole.

\section{Determinatezza}\marginpar{Mancino}

La proprietà di determinatezza asserisce che un qualunque oggetto
sintattico non può avere due semantiche differenti. In particolare,
possiamo dimostrare il seguente

\begin{teorema} \summary{(Determinatezza.)}
La semantica big-step del frammento di $\AExp$ data nella
sezione~\textup{\ref{sec:primo-esempio-semantica-big-step}}
gode della proprietà di determinatezza, ossia
per ogni $E \in \AExp$ e per ogni $n, n' \in \Zset$,
se $E \Downarrow n$ e $E \Downarrow n'$ allora $n = n'$.
\end{teorema}

\begin{proof}
La dimostrazione è per induzione strutturale sulla struttura di E.

Caso base: $n \in \Zset$.
In questo caso abbiamo che $n \Downarrow n_1$ e che $n \Downarrow n_2$.
Lo schema B-NUM implica che $n = n_1$ e $n = n_2$ e,
per la transitività dell'uguaglianza, $n_1 = n_2$.

Passo induttivo: $E \in \AExp$ con $E = E_1 + E_2$.
In questo caso abbiamo che $(E_1 + E_2) \Downarrow m_3$
e $(E_1 + E_2) \Downarrow p_3$.
Lo schema B-ADD implica che esistono
$m_1, m_2, p_1, p_2 \in Num$ tali che:
\begin{align*}
  m_1 + m_2 &= m_3, & E_1 &\Downarrow m_1, & E_2 &\Downarrow m_2, \\
  p_1 + p_2 &= p_3, & E_1 &\Downarrow p_1, & E_2 &\Downarrow p_2.
\end{align*}
Ma allora, per ipotesi induttiva:
\begin{align*}
m_1 &= p_1, & m_1+m_2 &= m_3 \\
m_2 &= p_2, & p_1 + p_2 &= p_3
\end{align*}
Da cui deduciamo che $ m_1 + m_2 = p_1 + p_2$, per cui
$m_3 = p_3$ come volevamo dimostrare.
\end{proof}

\section{Normalizzazione}\marginpar{Mancino}
La proprietà di normalizzazione asserisce che per ogni espressione $E$ esiste almeno un risultato
$n$ tale che $E \Downarrow n$.

Osserviamo che, in generale, ci sono esempi in cui non è possibile normalizzare:
$$ while \; true \; do \; skip \; \Downarrow \; ? $$
A destra dell'operatore di ``valuta a'' non posso scriverci nulla, il ciclo non termina.
Un altro esempio è il seguente:
$$ \nicefrac{0}{0} \; \Downarrow \; ? $$
A destra dell'operatore di ``valuta a'' posso scrivere la codifica del disastro (se esiste)
altrimenti, come nel caso precedente, non possiamo scriverci nulla.

\begin{teorema}[Normalizzazione]
La semantica big-step del frammento di $\AExp$ data nella
sezione~\textup{\ref{sec:primo-esempio-semantica-big-step}}
gode della proprietà di normalizzazione, ossia per ogni
$E \in Exp$ esiste  $n \in \Zset$ tale che $E \Downarrow n$.
\end{teorema}

\section{Semantica big-step per While}\marginpar{Mancino}
Invece di usare un semplice frammento di linguaggio come quello descritto nel capitolo
precedente possiamo anche definire tramite la big-step la semantica del linguaggio WHILE.
Precisiamo allora che una coppia (\emph{comando, stato}) viene valutata ad un
nuovo stato, ossia, dato un comando $C$ e uno stato $s$, in generale:

$$
\langle C,s \rangle \Downarrow s'
$$

Con questa premessa, definendo con $E$ la generica espressione, con $C$
il generico comando e con $s$ il generico stato,
è facile immaginare il comportamento di tutti i comandi per while:

\begin{align*}
\prooftree
   \justifies
   		\langle skip,s \rangle \Downarrow s
\endprooftree
&&
\prooftree
	E \Downarrow n
   \justifies
   		\langle x:=E,s \rangle \Downarrow s[n \rightarrow x]
\endprooftree
\end{align*}

\begin{align*}
\prooftree
	B \Downarrow true \; \; \langle C_1,s \rangle \Downarrow s'
   \justifies
   		\langle if \; B \; then \; C_1 \; else \; C_2, s \rangle \Downarrow s'
\endprooftree
&&
\prooftree
	B \Downarrow false \; \; \langle C_2,s \rangle \Downarrow s'
   \justifies
   		\langle if \; B \; then \; C_1 \; else \; C_2, s \rangle \Downarrow s'
\endprooftree
\end{align*}

\begin{align*}
\prooftree
	\langle C_1,s \rangle \Downarrow s' \; \; \langle C_2,s' \rangle \Downarrow s''
   \justifies
   		\langle C_1; \; C_2,s \rangle \Downarrow s''
\endprooftree
\end{align*}

Infine rimane la regola del while, da cui il linguaggio prende il nome,
per la quale abbiamo due comportamenti distinti:

\begin{align*}
\prooftree
	B \Downarrow true \; \; \langle C;s \rangle \Downarrow s' \; \;
	\langle while \; B \; do \; C, s' \rangle \Downarrow s''
   \justifies
   		\langle while \; B \; do \; C,s \rangle \Downarrow s''
\endprooftree
&&
\prooftree
	B \Downarrow false
   \justifies
   		\langle while \; B \; do \; C, s \rangle \Downarrow s
\endprooftree
\end{align*}

\section{Effetti collaterali}\marginpar{Mancino}
In questo paragrafo ridefiniamo la semantica data precedentemente
per il linguaggio WHILE introducendo degli effetti collaterali.

\begin{definizione} \summary{(Effetti collaterali.)}
Si dice che si verifica un \emph{effetto collaterale} quando
una funzione modifica un valore o uno stato al di fuori del proprio
scoping locale.
\end{definizione}

In questo caso, dobbiamo ricordarci che, rispetto alle definizioni date
nel paragrafo precedente, detto $C$ il generico comando, $E$ la generica espressione,
$s$ il generico stato, si ha:

\begin{align*}
\langle C,s \rangle &\Downarrow s' \\
\langle E,s \rangle &\Downarrow \langle n,s \rangle
\end{align*}

Partendo da questo assunto non è quindi difficile ricostruire la semantica:

\begin{align*}
\prooftree
   \justifies
   		\langle skip,s \rangle \Downarrow s
\endprooftree
&&
\prooftree
	\langle E,s \rangle \Downarrow \langle n,s' \rangle
   \justifies
   		\langle x:=E,s \rangle \Downarrow s'[n \rightarrow x]
\endprooftree
\end{align*}

\begin{align*}
\prooftree
	\langle B,s \rangle \Downarrow \langle true,s' \rangle \; \; \langle C_1,s' \rangle \Downarrow s''
   \justifies
   		\langle if \; B \; then \; C_1 \; else \; C_2, s \rangle \Downarrow s''
\endprooftree
&&
\prooftree
	\langle B,s \rangle \Downarrow \langle true,s' \rangle \; \; \langle C;s' \rangle \Downarrow s'' \; \;
	\langle while \; B \; do \; C, s' \rangle \Downarrow s'''
   \justifies
   		\langle while \; B \; do \; C,s \rangle \Downarrow s'''
\endprooftree
\end{align*}

E così via per le restanti.
