\chapter{Semantica denotazionale}

\section{Introduzione} \marginpar{Marano}
% Aggiustare intro
In questo capitolo daremo una semantica denotazionale al linguaggio WHILE. Vedremo quindi la semantica di ogni elemento sintattico sotto forma di struttura matematica, per fare ciò definiremo varie funzioni che manipolano funzioni.
Ogni comando è perciò visto come uno \emph{State Transformer}, ovvero una funzione che prende uno store come argomento e, se per tale store è definita, allora mi restituisce un altro store. È quindi una funzione parziale, possiamo farla diventare totale ampliando il codominio con un nuovo simbolo $\bot$ che rappresenta il caso indefinito di stack o di ciclo infinito. Definiamo quindi il nuovo codominio $\Sigma_\bot = \Sigma \cup \left\{\bot\right\}$.
\begin{align*}
	&\pard{\ST}{\Sigma}{\Sigma}
	&\fund{\ST}{\Sigma}{\Sigma_\bot} 
\end{align*}

Questo è dunque il dominio semantico dei comandi del linguaggio WHILE, vediamo ora i domini semantici per le espressioni e per i booleani che sono definiti in modo esattamente analogo.

\begin{align*}
	&\pard{P}{\Sigma}{B}
	&\fund{P}{\Sigma}{B_\bot} 
\end{align*}

\begin{align*}
	&\pard{E}{\Sigma}{\Nset}
	&\fund{E}{\Sigma}{\Nset_\bot} 
\end{align*}

Vediamo quindi le funzioni semantiche per il linguaggio WHILE, queste sono funzioni di ordine superiore che prendono come argomento una funzione e restituiscono un'altra funzione. Ciò accade sempre visto che si tratta di funzioni totali poiché tutti i comandi, i booleani e le espressioni hanno una semantica (tralasciamo per semplicità quelli sintatticamente errati).

\begin{gather*}
\fund{\calC \llbracket - \rrbracket}{\Com}{\ST}
\pts
\fund{\calB \llbracket - \rrbracket}{\BExp}{P} 
\pts
\fund{\calE \llbracket - \rrbracket}{\AExp}{E} 
\end{gather*}

\section{Definizione delle semantica di AExp} \marginpar{Marano}
Abbiamo visto come è fatta la funzione semantica per le espressioni ma ora dobbiamo vedere cosa accade nei vari casi di espressione. La semantica della costante associa semplicemente alla costante $n$ il suo valore numerico.
$$ \denot{\calE}{n}{s} \defeq \llbracket n \rrbracket_{Num}$$
La semantica della somma invece associa alla somma di due espressioni la somma della semantica di queste due espressioni, se tali semantiche esistono:
$$ \denot{\calE}{E_1 + E_2}{s} \defeq \begin{cases}
	\denot{\calE}{E_1}{s} + \denot{\calE}{E_2}{s} & \text{se } \denot{\calE}{E_1}{s} \neq \bot \land \denot{\calE}{E_2}{s} \neq \bot;\\
	\bot & \text{se } \denot{\calE}{E_1}{s} = \bot \lor \denot{\calE}{E_2}{s} = \bot;\\
	\end{cases}
$$
Vedremo in seguito come poter eliminare questa e altre funzioni per casi definendo nuove funzioni come per esempio la somma $\conadd$ in $\Nset_\bot$.

\section{Definizione della semantica di Com} \marginpar{Marano}
Ora vediamo la semantica dei vari comandi presenti nel linguaggio WHILE:

\begin{align*}
&\denot{\calC}{x \weq E}{s} \defeq \begin{cases}
	\assign{s}{x}{\denot{\calE}{E}{s}} & \text{se } \denot{\calE}{E}{s} \neq \bot;\\
	\bot & \text{altrimenti};
	\end{cases}
\pts
&\denot{\calC}{\kw{skip}}{s} \defeq s
\pts
&\denot{\calC}{C_1 ; C_2}{s} \defeq \begin{cases}
	\bot & \text{se } \denot{\calC}{C_1}{s} = \bot;\\
	\denot{\calC}{C_2}{\denot{\calC}{C_1}{s}} & \text{altrimenti};\\
	\end{cases}
\pts
&\denot{\calC}{\condif{B}{C_1}{C_2}}{s} \defeq \begin{cases}
	\denot{\calC}{C_1}{s} & \text{se } \denot{\calB}{B}{s} = \ttv ;\\
	\denot{\calC}{C_2}{s} & \text{se } \denot{\calB}{B}{s} = \ffv ;\\
	\bot & \text{altrimenti};
	\end{cases}
\pts
&\denot{\calC}{\while{B}{C}}{s} \defeq \denot{\calC}{\condif{B}{(C ; \while{B}{C}}{\kw{skip}}}{s}
\end{align*}

Daremo in seguito una semantica più precisa del comando while e vedremo anche che tale comando, che come abbiamo detto sopra è una funzione, è continuo.

\section{Eliminazione funzioni per casi} \marginpar{Marano}
Vediamo ora come ridefinire alcune di queste semantiche in modo da non avere funzioni per casi, per ottenere tale risultato basta ampliare la definizione di alcuni operatori. Prendiamo per esempio la semantica della somma, in tal caso basta definire l'operatore di somma tra $\Nset_\bot$ in modo che se sommo due numeri naturali ottengo lo stesso risultato che otterrei normalmente con la somma che conosciamo, mentre se sommo $\bot$ con un naturale o con un altro $\bot$ ottengo ancora $\bot$:
$$\fund{\conadd}{\Nset_\bot \times \Nset_\bot}{\Nset_\bot} \defeq \lambda n_1, n_2 \in \Nset_\bot . \begin{cases}
	n_1 + n_2 & \text{se } n_1, n_2 \in \Nset;\\
	\bot & \text{altrimenti;}
	\end{cases}$$
Ora quindi possiamo semplicemente dire che la semantica della somma è:
$$\denot{\calE}{E_1 + E_2}{s} = \denot{\calE}{E_1}{s} \conadd \denot{\calE}{E_2}{s}$$

Esattamente allo stesso modo ora definiremo delle funzioni che mappano State Transformer in State Transformer e che non hanno bisogno di trattare in maniera separata i vari casi:
\begin{gather*}
\fund{\mathrm{seq}}{\ST \times \ST}{\ST} \\
\mathrm{seq}(f,g)(s) \defeq \begin{cases}
	\bot & \text{se } f(s) = \bot;\\
	g(f(s)) & \text{altrimenti};
	\end{cases}\\
\pts
\fund{\mathrm{cond}}{P \times \ST \times \ST}{\ST} \\
\mathrm{cond}(p,f,g)(s) \defeq \begin{cases}
	f(s) & \text{se } p(s) = \ttv;\\
	g(s) & \text{se } p(s) = \ffv;\\
	\bot & \text{altrimenti};
	\end{cases}\\
\end{gather*}

Perciò rivediamo le semantiche di questi due comandi:
$$ \denot{\calC}{C_1 ; C_2}{s} = \mathrm{seq}(\calC \llbracket C_1 \rrbracket, \calC \llbracket C_2 \rrbracket)(s)$$

$$\denot{\calC}{\condif{B}{C_1}{C_2}}{s} = \mathrm{cond}(\calB \llbracket B \rrbracket, \calC \llbracket C_1 \rrbracket, \calC \llbracket C_2 \rrbracket)(s)$$.

Proviamo a riscrivere anche la semantica del comando while e otteniamo un risultato molto interessante:
$$ \denot{\calC}{\while{B}{C}}{s} = \denot{\calC}{\condif{B}{(C ; \while{B}{C}}{\kw{skip}}}{s}$$
ma ponendo ora $f = \mathrm{cond}(\calB \llbracket B \rrbracket, \mathrm{seq}(\calC \llbracket C \rrbracket, f), \mathrm{id})$ dove con $id$ intendiamo la semantica del comando $\kw{skip}$.
Otteniamo quindi, definendo $\fund{F}{\ST}{\ST}$ come $F(f) \defeq \mathrm{cond}(\calB \llbracket B \rrbracket, \mathrm{seq}(\calC \llbracket C \rrbracket, f), \mathrm{id})$ che $f$ è un punto fisso di $F$, ovvero che per trovare la semantica del comando while ci basta trovare il punto fisso di tale funzione, per fare ciò sfrutteremo il Teorema di Tarski visto precedentemente. Per usare però tale teorema dobbiamo prima dimostrare che $\ST$ è effettivamente un CPO:

\begin{proposizione} \summary{($(ST, \sqsubseteq)$ è un CPO.)}
Sia ST l'insieme degli State Transformer e sia $\reld{\sqsubseteq}{ST}{ST}$ una relazione binaria di ordinamento parziale che presi due State Transformer $f$ e $g$ si ha che $f \sqsubseteq g$ se $g$ è più definita di $f$, ovvero in simboli: $\forall f,g \in ST \itc f \sqsubseteq g \Longleftrightarrow \forall s \in \Sigma \itc f(s)\convrg \Rightarrow f(s) = g(s)$. Allora $(ST, \sqsubseteq)$ è un CPO.
\end{proposizione}
\begin{proof}
Poniamo dunque $\bot$ minimo di ST visto che è lo State Transformer meno definito: $\bot \in ST \itc \forall s \in \Sigma \itc \bot(s)\divrg$ perciò è ovvio che $\forall f \in ST \itc \bot \sqsubseteq f$, dunque $\bot = \min ST$. 
Sia $I \subseteq \Nset \itc C = \left\{a_i\right\}_{i \in I}$ allora se $I$ è numerabile ($|I| < \aleph_0$) allora il $\lub$ è l'elemento massimo nella catena. Se invece $|I| = \aleph_0$ definisco:
	$\forall x \in \Sigma \itc f_l(x) =
    \begin{cases}
      f_h(x) & \text{se } \exists i \in I : f_h(x)\convrg;\\
      \divrg & \text{altrimenti}
    \end{cases}\\ $
È ovvio che quello appena definito è proprio il $\lub$ visto che è definito almeno come ogni altro State Transformer, dimostriamolo applicando la deifinizione di $\lub$.
$u = lub\ C \Longleftrightarrow (\forall i \in I \itc f_i \sqsubseteq u) \land (\forall u' \in ST \itc (\forall j \in I \itc f_j \sqsubseteq u') \Rightarrow u \sqsubseteq u')$.
Quindi prendiamo un qualsiasi State Transformer $f_i \in C$ e dimostriamo che è minore di $f_l$ tramite la relazione sopra definita, dobbiamo quindi dimostrare che se converge per un qualsiasi store $s \in \Sigma$ allora anche $f_l$ converge. Sia $i \in I \itc \forall s \in \sum \itc f_i(s)\convrg$ allora esiste un $i \in I$ per il quale $f_i$ converge, perciò $f_l$ convergerà a quello stesso valore per definizione: $(f_l(s)\convrg \land f_l(s)=f_i(s))$\\
Perciò $\forall j \in I \itc f_j \sqsubseteq f_l$ dunque  $f_l = \lub C$. Visto che $(ST, \sqsubseteq)$ ha minimo e ogni sua catena ha $\lub$ è un CPO.
\end{proof}

\section{Effetti collaterali} \marginpar{Marano}
Finora abbiamo tralasciato gli effetti collaterali ovvero, come già detto nei capitoli precedenti, abbiamo escluso (per semplificare la spiegazione) la possibilità che la valutazione di espressioni o di booleani cambi lo store. Se volessimo introdurre gli effetti collaterali dovremmo semplicemente modificare leggermente le definizioni viste sopra:
$$ \denot{\calE}{n}{s} \defeq \llbracket n \rrbracket_{Num}$$
La semantica della valutazione di una costante ovviamente non varia, come non varia quella dello $\kw{skip}$ e quella della composizione sequenziale visto che non contengono né espressioni né booleani.

\begin{align*}
&\denot{\calE}{E_1 + E_2}{s} \defeq \denot{\calE}{E_1}{s} \conadd \denot{\calE}{E_2}{\denot{\calE}{E_1}{s}}\\
&\denot{\calC}{x \weq E}{s} \defeq \begin{cases}\\
	\assign{\denot{\calE}{E}{s}}{x}{\denot{\calE}{E}{s}} & \text{se } \denot{\calE}{E}{s} \neq \bot;\\
	\bot & \text{altrimenti};
	\end{cases}\\
&\denot{\calC}{\kw{skip}}{s} \defeq s\\
&\denot{\calC}{C_1 ; C_2}{s} \defeq \mathrm{seq}(\calC \llbracket C_1 \rrbracket, \calC \llbracket C_2 \rrbracket)(s)\\
&\denot{\calC}{\condif{B}{C_1}{C_2}}{s} \defeq \begin{cases}\\
	\denot{\calC}{C_1}{\denot{\calB}{B}{s}} & \text{se } \denot{\calB}{B}{s} = \ttv ;\\
	\denot{\calC}{C_2}{\denot{\calB}{B}{s}} & \text{se } \denot{\calB}{B}{s} = \ffv ;\\
	\bot & \text{altrimenti};
	\end{cases}\\
&\denot{\calC}{\while{B}{C}}{s} \defeq \denot{\calC}{\condif{B}{(C ; \while{B}{C}}{\kw{skip}}}{\denot{\calB}{B}{s}}
\end{align*}

\section{Continuità del comando While}\marginpar{Mancino}
Il comando $ while\; B\; do\; C $ è continuo.

\begin{proof}

  Il comando $$\emph{C}\llbracket while\; B\; do\; C \rrbracket $$ è riconducibile a:
  $$ \emph{C}\llbracket if\; B\; then\; (C;\; while\; B\; do\; C)\; else\; skip \rrbracket = $$
  $$ = cond( \emph{B}\llbracket B \rrbracket\; ,\; seq(\emph{C}\llbracket C \rrbracket , C \llbracket \\ while\; B\; do\; C \rrbracket , id ) $$
  $$ = cond( \emph{B}\llbracket B \rrbracket\;, \emph{C}\llbracket while\; B\; do\; C \rrbracket \circ \emph{C}\llbracket C \rrbracket , id) $$

  Ora sia:
  $$ f = cond(B \llbracket B \rrbracket , f \circ C \llbracket C \rrbracket , id) $$
  E sia:
  $ f = F(f) $, con:
  $$ F = \lambda f . cond(\emph{B} \llbracket B \rrbracket , f \circ C \llbracket C \rrbracket , id) $$
  dove $ F: ST \rightarrow ST $. Dobbiamo dimostrare che F è continua. Dimostriamo in primo luogo che il \emph{lub} esiste. Per farlo, presi \emph{b} e \emph{g} generici e $ \emph{X} \subseteq ST \land chain(X) $, facciamo vedere che $$ cond(b,X,g) $$ è monotono sul secondo argomento, tenendo fissi il primo e il terzo argomento:
  $$ (f_1 \sqsubseteq f_2) \rightarrow cond(b,f_{1},g) \sqsubseteq cond(b,f_{2},g) $$
  Preso $s \in \Sigma $ generico, ipotizzo che:
  $$ cond(b,f_1,g)(s) \downarrow $$
  sia definito. Allora ci sono due possibilità:
  \begin{enumerate}
  \item $ b(s) = false $ \\
    $ cond(b,f_1,g)(s)=g(s)=cond(b,f_2,g)(s) $
  \item $ b(s) = true $ \\
    $ cond(b,f_1,g)(s) = f_{1}(s) \sqsubseteq f_{2}(s) = cond(b,f_2,g)(s) $
  \end{enumerate}
  Concludiamo allora che la monotonia vale. \\
  Sia ora $ X \subseteq ST \; . \; chain(X) $. Allora dimostriamo che:
  $$ chain( \{cond(b,f,g) | f \in X\}) $$
  La cardinalità di questo insieme è minore o uguale a quella di \emph{X}, e quindi di $ \aleph_0 $. In particolare se \emph{X} è infinito c'è almeno un elemento che è g (quando b è falso). Quindi l'insieme è numerabile. \\ Ora devo dimostrare che è totalmente ordinato. Siano $f_1,f_2 \in \emph{X}$ generiche tali che \emph{chain(X)}. Allora:
  \begin{enumerate}
  \item $cond(b,f_1,g) \sqsubseteq cond(b,f_2,g)$, oppure
  \item $cond(b,f_2,g) \sqsubseteq cond(b,f_1,g)$
  \end{enumerate}
  Dato che \emph{X} è una catena, $f_1 \sqsubseteq f_2 \lor f_2 \sqsubseteq f_1 $. E otteniamo nel primo caso la (1) mentre la (2) nel secondo caso. Siaccome siamo in un \emph{CPO} concludiamo che il lub esiste. \\
  Ora dobbiamo far vedere chi è il lub. Intuitivamente è:
  $$ lub( \{ cond(b,f,g) \; | \; f \in X \})= \begin{cases} \uparrow , & \mbox{se } b(s)=true \land \forall f \in X f(s) \uparrow \; \\ g(s), & \mbox{se } b(s)=false \; \\ f(s) & \mbox{se } b(s)=true \land f \in X \mbox{ tale che } f(s) \downarrow
  \end{cases} $$
  Dobbiamo dimostrare che il \emph{lub} è proprio lui e che:
  $$ lub(cond(b,X,g)) = cond(b, lub\; X, g) $$
  In questo modo avremo dimostrato che \emph{cond} è continuo sul secondo argomento. Chiamiamo allora \emph{h(s)} l'espressione in parentesi graffe e dimostriamo che h(s) è proprio il \emph{lub} di:
  $$ \{cond(b,f,g) | f \in X \} $$
  Si ha $ \forall b \in BT, \forall g \in ST, \forall f \in X : cond(b,f,g) \sqsubseteq h $, cioè che:
  $$ \forall f_1, f_2 \in ST : f_1 \sqsubseteq f_2 \Leftrightarrow $$
  $$ \Leftrightarrow \forall s \in \Sigma \mbox{ tale che } f_{1}(s) \downarrow \Rightarrow f_{2}(s) \downarrow \land f_{2}(s) = f_{1}(s) $$
  Applicando la suddetta definizione:
  \begin{itemize}
  \item Se \emph{h(s)} diverge non c'è nulla da dimostrare;
  \item Supponiamo che $cond(b,f,g)$ converga. Dobbiamo dimostrare che:
    $$ \forall s \in \Sigma \mbox{ tale che } cond(b,f,g)(s) \downarrow \Rightarrow h(s) \downarrow \land cond(b,f,g)(s) = h(s) $$
    Ci sono due ulteriori casi:
    \begin{enumerate}
    \item Se $b(s) = false$ per definizione di \emph{cond}:
      $$ cond(b,f,g)(s) = g(s) \land h(s) = g(s) $$
    \item Se $b(s)=true$ per definizione di \emph{cond}:
      $$ cond(b,f,g)(s) = f(s) \Rightarrow f(s) \downarrow $$
      Poichè $f \in X$ e sappiamo che termina, siamo nel terzo caso. Ma allora:
      $$ h(s) = f(s) $$
    \end{enumerate}
  \end{itemize}

  Quindi sappiamo che è un upper bound, dobbiamo solo dimostrare che è il lub. Dobbiamo cioè dimostrare che:
  $$ lub( \{ (cond(b,f,g)) | f \in X \} ) = cond(b, lub \; X, g) $$
  Sia $s \in \Sigma$ arbitrario. Sia:
  $$ h(s) = cond(b,lub \; X, g)(s) $$
  Scartiamo la possibilità di non terminazione. Allora abbiamo due casi:
  \begin{enumerate}
  \item $b(s) = false \Rightarrow h(s) = g(s) $ \\
    $g(s) = cond(b,lub \; X, g)(s) $, per definizione di cond.
  \item $b(s)=true$ \\
    Abbiamo due ulteriori casi:
    \begin{itemize}
    \item $b(s) = true \land \forall f \in X \; : \; f(s)
      \uparrow \; \Rightarrow lub \; X \uparrow$ \\
      Cioè se non termina da un lato, non termina neanche dall'altro.
    \item $b(s)=true \land f \in X : f(s) \downarrow$
      Allora:
      $$ lub \; X(s) = f(s) $$
      Come ci si aspettava.
    \end{itemize}
  \end{enumerate}
  Quindi \emph{cond} è effettivamente continuo sul secondo argomento.\\
  Ci rimane da far vedere che se \emph{X} è una catena e compongo tutti gli elementi della catena con uno \emph{ST} allora ottengo sempre una catena, cioè:
  $$ \forall g \in ST : \forall X \subseteq ST : chain(X) \; \Rightarrow chain(\{ f \circ g | f \in X \} ) $$
  In particolare se $f = \perp$ l'insieme è un singoletto. \\
  Dimostriamo quanto scritto ante:
  \begin{itemize}
  \item L'insieme è enumerabile (banalmente vero).
  \item Per dimostrare che è totalmente ordinato devo far vedere che:
    $$ \forall f_1 , f_2 \in X : f \circ g \sqsubseteq f_2 \lor f_2 \circ g \sqsubseteq f_1 $$
    Facciamo vedere che vale una delle due, per esempio la prima:
    $$ f_1 \sqsubseteq s_2 \Rightarrow f_1 \circ g \sqsubseteq f_2 \circ g $$
    Applicando la definizione di $ \sqsubseteq $ si ha:
    $$ \forall s \in \Sigma : f_{1}(s) \downarrow \; \Rightarrow f_{2}(s) \downarrow
    \land f{1}(s)=f_{2}(s) \; \; (*) $$
    Questo è dato. Voglio dimostrare che:
    $$ \forall s \in \Sigma : f_1 \circ g(s) \downarrow \; \Rightarrow f_2 \circ g(s)
    \downarrow \land f_2 \circ g(s) = f_1 \circ g(s) $$
    Che sarebbe:
    $$ \forall s \in \Sigma : f_{1}(g(s)) \downarrow \; \Rightarrow f_{2}(g(s))
    \downarrow \land f_{1}(g(s)) = f_{2}(g(s)) $$
    Che è vera per la (*) ed è proprio quello che ci serve. \\
    L'altro caso è assolutamente duale.
  \end{itemize}
  Abbiamo dimostrato allora la continuità della funzione:
  $$ \forall b \in PT \forall g,h \in ST \; \lambda f \; . \; cond(b,f \circ h,g) $$
  Questa è la \emph{F} che risulta quindi continua. Per il \emph{Teorema di Tarski} possiede un minimo punto fisso che si trova facendo le iterate successive a partire da $\perp$ . Allora possiamo concludere che:
  $$ \emph{C} \llbracket while \; B \; do \; C \rrbracket = lfp \; F $$
  E:
  $$ lfp \; F = lub \{ F^n(\perp ) | n \in \mathbb{N} \} $$
\end{proof}