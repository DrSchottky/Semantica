\chapter{Semantica denotazionale}

\section{Introduzione} \marginpar{Marano}
% Aggiustare intro
In questo capitolo daremo una semantica denotazionale al linguaggio WHILE. Vedremo quindi la semantica di ogni elemento sintattico sotto forma di struttura matematica, per fare ciò definiremo varie funzioni che manipolano funzioni.
Ogni comando è perciò visto come uno \emph{State Transformer}, ovvero una funzione che prende uno store come argomento e, se per tale store è definita, allora mi restituisce un altro store. È quindi una funzione parziale, possiamo farla diventare totale ampliando il codominio con un nuovo simbolo $\bot$ che rappresenta il caso indefinito di stack o di ciclo infinito. Definiamo quindi il nuovo codominio $\Sigma_\bot = \Sigma \cup \left\{\bot\right\}$.
\begin{align*}
        &\pard{\ST}{\Sigma}{\Sigma}
        &\fund{\ST}{\Sigma}{\Sigma_\bot} 
\end{align*}

Questo è dunque il dominio semantico dei comandi del linguaggio WHILE, vediamo ora i domini semantici per le espressioni e per i booleani che sono definiti in modo esattamente analogo.

\begin{align*}
        &\pard{P}{\Sigma}{B}
        &\fund{P}{\Sigma}{B_\bot} 
\end{align*}

\begin{align*}
        &\pard{E}{\Sigma}{\Nset}
        &\fund{E}{\Sigma}{\Nset_\bot} 
\end{align*}

Vediamo quindi le funzioni semantiche per il linguaggio WHILE, queste sono funzioni di ordine superiore che prendono come argomento una funzione e restituiscono un'altra funzione. Ciò accade sempre visto che si tratta di funzioni totali poiché tutti i comandi, i booleani e le espressioni hanno una semantica (tralasciamo per semplicità quelli sintatticamente errati).

\begin{gather*}
\fund{\calC \llbracket - \rrbracket}{\Com}{\ST}
\pts
\fund{\calB \llbracket - \rrbracket}{\BExp}{P} 
\pts
\fund{\calE \llbracket - \rrbracket}{\AExp}{E} 
\end{gather*}

\section{Definizione delle semantica di AExp} \marginpar{Marano}
Abbiamo visto come è fatta la funzione semantica per le espressioni ma ora dobbiamo vedere cosa accade nei vari casi di espressione. La semantica della costante associa semplicemente alla costante $n$ il suo valore numerico.
$$ \denotE{n}{s} \defeq \llbracket n \rrbracket_{\Integer}$$
La semantica della somma invece associa alla somma di due espressioni la somma della semantica di queste due espressioni, se tali semantiche esistono:
$$ \denotE{E_1 + E_2}{s} \defeq \begin{cases}
        \denotE{E_1}{s} + \denotE{E_2}{s}, &\text{se $\denotE{E_1}{s} \neq \bot$ e $\denotE{E_2}{s} \neq \bot$;}\\
      	\bot, &\text{altrimenti.}\\
        \end{cases}
$$
Vedremo in seguito come poter eliminare questa e altre funzioni per casi definendo nuove funzioni come per esempio la somma $\conadd$ in $\Nset_\bot$.

\section{Definizione della semantica di Com} \marginpar{Marano}
Ora vediamo la semantica dei vari comandi presenti nel linguaggio WHILE:

\begin{align*}
&\denotC{x \weq E}{s} \defeq \begin{cases}
        \bigassign{s}{x}{\denotE{E}{s}}, &\text{se $\denotE{E}{s} \neq \bot$;}\\
        \bot, &\text{altrimenti.}
        \end{cases}
\pts
&\denotC{\kw{skip}}{s} \defeq s;
\pts
&\denotC{C_1 ; C_2}{s} \defeq \begin{cases}
        \bot, &\text{se $\denotC{C_1}{s} = \bot$;}\\
        \denotC{C_2}{\denotC{C_1}{s}}, &\text{altrimenti.}\\
        \end{cases}
\pts
&\denotC{\condif{B}{C_1}{C_2}}{s} \defeq \begin{cases}
        \denotC{C_1}{s}, &\text{se $\denotB{B}{s} = \ttv$;}\\
        \denotC{C_2}{s}, &\text{se $\denotB{B}{s} = \ffv$;}\\
        \bot, &\text{altrimenti.}
        \end{cases}
\pts
\end{align*}

Daremo in seguito una semantica più precisa del comando while, per ora possiamo solo stabilire l'uguaglianza
$$\denotC{\while{B}{C}}{s} = \denotC{\condif{B}{(C ; \while{B}{C}}{\kw{skip}}}{s}$$

\section{Eliminazione funzioni per casi} \marginpar{Marano}
\label{sec:definizione di F}
Vediamo ora come ridefinire alcune di queste semantiche in modo da non avere funzioni per casi, per ottenere tale risultato basta ampliare la definizione di alcuni operatori. Prendiamo per esempio la semantica della somma, in tal caso basta definire l'operatore di somma tra $\Nset_\bot$ in modo che se sommo due numeri naturali ottengo lo stesso risultato che otterrei normalmente con la somma che conosciamo, mentre se sommo $\bot$ con un naturale o con un altro $\bot$ ottengo ancora $\bot$:
$$\fund{\conadd}{\Nset_\bot \times \Nset_\bot}{\Nset_\bot} \defeq \lambda n_1, n_2 \in \Nset_\bot . \begin{cases}
        n_1 + n_2, &\text{se $n_1, n_2 \in \Nset$;}\\
        \bot, &\text{altrimenti.}
        \end{cases}$$
Ora quindi possiamo semplicemente dire che la semantica della somma è:
$$\denotE{E_1 + E_2}{s} = \denotE{E_1}{s} \conadd \denotE{E_2}{s}$$

Esattamente allo stesso modo ora definiremo delle funzioni che mappano State Transformer in State Transformer e che non hanno bisogno di trattare in maniera separata i vari casi:
\begin{gather*}
\fund{\mathrm{seq}}{\ST \times \ST}{\ST} \\
\mathrm{seq}(f,g)(s) \defeq \begin{cases}
        \bot, &\text{se $f(s) = \bot$;}\\
        g(f(s)), &\text{altrimenti.}
        \end{cases}\\
\pts
\fund{\mathrm{cond}}{P \times \ST \times \ST}{\ST} \\
\mathrm{cond}(p,f,g)(s) \defeq \begin{cases}
        f(s), &\text{se $p(s) = \ttv$;}\\
        g(s), &\text{se $p(s) = \ffv$;}\\
        \bot, &\text{altrimenti.}
        \end{cases}\\
\end{gather*}

Perciò rivediamo le semantiche di questi due comandi:
$$ \denotC{C_1 ; C_2}{s} = \mathrm{seq}(\calC \llbracket C_1 \rrbracket, \calC \llbracket C_2 \rrbracket)(s)$$

$$\denotC{\condif{B}{C_1}{C_2}}{s} = \mathrm{cond}(\calB \llbracket B \rrbracket, \calC \llbracket C_1 \rrbracket, \calC \llbracket C_2 \rrbracket)(s)$$.

Proviamo a riscrivere anche la semantica del comando while e otteniamo un risultato molto interessante:
$$ \denotC{\while{B}{C}}{s} = \denotC{\condif{B}{(C ; \while{B}{C}}{\kw{skip}}}{s}$$
ma ponendo ora $f = \mathrm{cond}(\calB \llbracket B \rrbracket, \mathrm{seq}(\calC \llbracket C \rrbracket, f), \mathrm{id})$ dove con $id$ intendiamo la semantica del comando $\kw{skip}$.
Definiamo $\fund{F}{\ST}{\ST}$ come:
\[
F(f) \defeq \mathrm{cond}(\calB \llbracket B \rrbracket, \mathrm{seq}(\calC \llbracket C \rrbracket, f), \mathrm{id})
\]
e otteniamo quindi che $f$ è un punto fisso di $F$, ovvero che per trovare la semantica del comando while ci basta trovare il punto fisso di tale funzione, per fare ciò sfrutteremo il Teorema di Tarski visto precedentemente. Per usare però tale teorema dobbiamo prima dimostrare che $\ST$ è effettivamente un CPO:

\begin{proposizione} \summary{($(ST, \sqsubseteq)$ è un CPO.)}
Sia ST l'insieme degli State Transformer e sia $\reld{\sqsubseteq}{ST}{ST}$ una relazione binaria di ordinamento parziale che presi due State Transformer $f$ e $g$ si ha che $f \sqsubseteq g$ se $g$ è più definita di $f$, ovvero in simboli: $\forall f,g \in ST \itc f \sqsubseteq g \Longleftrightarrow \forall s \in \Sigma \itc f(s)\convrg \Rightarrow f(s) = g(s)$. Allora $(ST, \sqsubseteq)$ è un CPO.
\end{proposizione}
\begin{proof}
Poniamo dunque $\bot$ minimo di ST visto che è lo State Transformer meno definito: $\bot \in ST \itc \forall s \in \Sigma \itc \bot(s)\divrg$ perciò è ovvio che $\forall f \in ST \itc \bot \sqsubseteq f$, dunque $\bot = \min ST$. 
Sia $I \subseteq \Nset \itc C = \left\{a_i\right\}_{i \in I}$ allora se $I$ è numerabile ($|I| < \aleph_0$) allora il $\lub$ è l'elemento massimo nella catena. Se invece $|I| = \aleph_0$ definisco:
        $\forall x \in \Sigma \itc f_l(x) =
    \begin{cases}
      f_h(x), &\text{se $\exists i \in I \itc f_h(x)\convrg$;}\\
      \divrg, &\text{altrimenti.}
    \end{cases}\\ $
È ovvio che quello appena definito è proprio il $\lub$ visto che è definito almeno come ogni altro State Transformer, dimostriamolo applicando la definizione di $\lub$.
$u = \lub C \Longleftrightarrow (\forall i \in I \itc f_i \sqsubseteq u) \land (\forall u' \in ST \itc (\forall j \in I \itc f_j \sqsubseteq u') \Rightarrow u \sqsubseteq u')$.
Quindi prendiamo un qualsiasi State Transformer $f_i \in C$ e dimostriamo che è minore di $f_l$ tramite la relazione sopra definita, dobbiamo quindi dimostrare che se converge per un qualsiasi store $s \in \Sigma$ allora anche $f_l$ converge. Sia $i \in I \itc \forall s \in \sum \itc f_i(s)\convrg$ allora esiste un $i \in I$ per il quale $f_i$ converge, perciò $f_l$ convergerà a quello stesso valore per definizione: $(f_l(s)\convrg \land f_l(s)=f_i(s))$\\
Perciò $\forall j \in I \itc f_j \sqsubseteq f_l$ dunque  $f_l = \lub C$. Visto che $(ST, \sqsubseteq)$ ha minimo e ogni sua catena ha $\lub$ è un CPO.
\end{proof}

\section{Continuità del comando While}\marginpar{Mancino}
In questo paragrafo dimostreremo il seguente risultato:

\begin{teorema}
La funzione $\fund{F}{\ST}{\ST}$ definita in sezione~\textup{\ref{sec:definizione di F}} è continua.
\end{teorema}

\begin{proof}
Dimostriamo in primo luogo che il $\lub$ esiste.
Per farlo, sia $ X \subseteq ST$ e valga $\chain(X)$.
Allora, presi $b \in P$ e $g \in \ST$ generici,
facciamo vedere che $ \cond(b,X,g) $ è monotono sul
secondo argomento, tenendo fissi il primo e il terzo argomento:
\[
  (f_1 \sqsubseteq f_2) \Rightarrow \cond(b,f_{1},g) \sqsubseteq \cond(b,f_{2},g)
\]
Preso $s \in \Sigma $ generico, ipotizzo che $\cond(b,f_1,g)(s)$
sia definito. Allora ci sono due possibilità:
\begin{enumerate}
  \item $b(s) = \false$, e dunque:
        \[ \cond(b,f_1,g)(s)=g(s)=\cond(b,f_2,g)(s) \]
  \item $ b(s) = \true $, e dunque:
        \[
          \cond(b,f_1,g)(s) = f_{1}(s)
          \sqsubseteq f_{2}(s) = \cond(b,f_2,g)(s)
        \]
        dove $f_{1}(s) \sqsubseteq f_{2}(s)$ è vera per ipotesi.
\end{enumerate}
La monotonia è allora dimostrata.

Sia ora $ X \subseteq ST$ tale che $\chain(X) $. Allora dimostriamo che:
\[
  \chain\bigl( \{\cond(b,f,g) | f \in X\}\bigr)
\]
La cardinalità di questo insieme è minore o uguale
a quella di $X$, e quindi di $\aleph_0$.
In particolare se $X$ è infinito c'è almeno un elemento
che è $g$ (quando $b$ è falso). Quindi l'insieme è numerabile.
Rimane da dimostrare che è totalmente ordinato.
Siano $f_1,f_2 \in X$ generiche tali che $\chain(X)$.
Per quanto dimostrato prima, allora:
\begin{enumerate}
  \item $\cond(b,f_1,g) \sqsubseteq \cond(b,f_2,g)$, oppure
  \item $\cond(b,f_2,g) \sqsubseteq \cond(b,f_1,g)$.
\end{enumerate}
Dato che $X$ è una catena, $f_1 \sqsubseteq f_2$ oppure
$f_2 \sqsubseteq f_1 $. E otteniamo nel primo caso la (1)
mentre la (2) nel secondo caso.
Siccome siamo in un $CPO$ (in cui per ogni catena esiste
un $\lub$) concludiamo che il $\lub$ esiste.

A questo punto, ci è necessario dare un aspetto al $\lub$,
definendolo esplicitamente. Intuitivamente è:
\[
  \lub\bigl( \{ \cond(b,f,g) \; | \; f \in X \}\bigr)=
  \begin{cases}
    \uparrow , & \textrm{se } b(s)=true \land \forall f \in X f(s) \uparrow \\
    g(s), & \textrm{se } b(s)=false \\
    f(s), & \textrm{se } b(s)=true \land f \in X \textrm{ tale che } f(s) \downarrow
  \end{cases}
\]
Dobbiamo dimostrare che il $\lub$ è proprio lui e che:
\[
  \lub \bigl(\cond(b,X,g)\bigr) = \cond(b, \lub X, g)
\]
In questo modo avremo provato formalmente che $\cond$ è continuo
sul secondo argomento. 
Per semplicità notazionale, sia:
\[
  h(s) \defeq
  \begin{cases}
    \uparrow , & \textrm{se } b(s)=true \land \forall f \in X f(s) \uparrow \\
    g(s), & \textrm{se } b(s)=false \\
    f(s), & \textrm{se } b(s)=true \land f \in X \textrm{ tale che } f(s) \downarrow
  \end{cases}
\]
Dimostriamo allora che:
\[
  h(s) = \lub \{\cond(b,f,g) | f \in X \}
\]
Si ha che $\forall b \in B, \forall g \in \ST, \forall f \in X$
vale $\cond(b,f,g) \sqsubseteq h $, cioè che:
\begin{multline*}
  \forall f_1, f_2 \in \ST : f_1 \sqsubseteq f_2 \Leftrightarrow \\
  \Leftrightarrow \forall s \in \Sigma \textrm{ tale che } f_{1}(s) \downarrow
  \, \Rightarrow f_{2}(s) \downarrow \land f_{2}(s) = f_{1}(s)
\end{multline*}
Applicando la suddetta definizione:
\begin{itemize}
  \item Se $h(s)$ diverge non c'è nulla da dimostrare;
  \item Supponiamo che $\cond(b,f,g)$ converga. Dobbiamo dimostrare che
    per ogni $s \in \Sigma$ tale che $\cond(b,f,g)(s) \downarrow$
    si ha $h(s) \downarrow$ e  anche $\cond(b,f,g)(s) = h(s)$.
  Ci sono due ulteriori casi:
  \begin{enumerate}
    \item Se $b(s) = \false$ per definizione di $\cond$:
    \[ \cond(b,f,g)(s) = g(s) \land h(s) = g(s) \]
    \item Se $b(s) = \true$ per definizione di $\cond$:
    \[ \cond(b,f,g)(s) = f(s) \Rightarrow f(s) \downarrow \]
    Poiché $f \in X$ e sappiamo che termina, siamo nel terzo caso della
    definizione di $\lub$. Ma allora:
    \[ h(s) = f(s) \]
   \end{enumerate}
\end{itemize}

Da queste considerazioni, sappiamo che è un upper bound.
Dobbiamo solo dimostrare che è il $\lub$. Dobbiamo cioè dimostrare che:
\[
  \lub \bigl\{ \bigl(\cond(b,f,g)\bigr) | f \in X \bigr\} = \cond(b, \lub X, g)
\]
Sia $s \in \Sigma$ arbitrario. Sia:
\[ h(s) = \cond(b,\lub X, g)(s) \]
Scartiamo la possibilità di non terminazione. Allora abbiamo due casi:
\begin{enumerate}
  \item $b(s) = \false \Rightarrow h(s) = g(s)$
    e, per definizione di $\cond$,
    $g(s) = \cond(b,\lub X, g)(s) $.
  \item $b(s)=\true$, abbiamo due ulteriori casi:
    \begin{itemize}
      \item $b(s) = \true \land \forall f \in X \st f(s)
      \uparrow \; \Rightarrow \lub X \uparrow$,
      cioè se non termina da un lato, non termina neanche dall'altro.
      \item $b(s)=\true \land f \in X \st f(s) \downarrow$
      Allora:
      \[ \lub \; X(s) = f(s) \]
      Come ci si aspettava.
    \end{itemize}
\end{enumerate}
Quindi $\cond$ è effettivamente continuo sul secondo argomento.

Ci rimane da far vedere che se $X$ è una catena e
componendo tutti gli elementi della catena con uno $\ST$
ottengo sempre una catena, cioè:
\[ 
  \forall g \in ST \st \forall X \subseteq ST 
  \st \chain(X) \Rightarrow \chain\bigl(\{ f \circ g | f \in X \} \bigr)
\]
In particolare se $f = \perp$ l'insieme è un singoletto.
Dimostriamolo:
\begin{itemize}
  \item L'insieme è enumerabile (banalmente vero).
  \item Per dimostrare che è totalmente ordinato devo far vedere che:
  \[ 
    \forall f_1 , f_2 \in X \st f \circ g \sqsubseteq f_2 \lor f_2
    \circ g \sqsubseteq f_1
  \]
  Facciamo vedere che vale una delle due, per esempio la prima:
  \[ f_1 \sqsubseteq s_2 \Rightarrow f_1 \circ g \sqsubseteq f_2 \circ g \]
  Applicando la definizione di $ \sqsubseteq $ si ha:
  \begin{equation}
    \forall s \in \Sigma \st f_{1}(s) \downarrow \; \Rightarrow f_{2}(s) \downarrow
    \land f{1}(s)=f_{2}(s)
    \label{eq:5.1}
  \end{equation}
   Voglio dimostrare che:
   \[ 
     \forall s \in \Sigma \st f_1 \circ g(s) \downarrow
     \; \Rightarrow f_2 \circ g(s) \downarrow \land f_2
     \circ g(s) = f_1 \circ g(s)
    \]
    Che sarebbe:
    \[ 
      \forall s \in \Sigma \st f_{1}(g(s)) \downarrow
      \; \Rightarrow f_{2}(g(s)) \downarrow \land f_{1}(g(s))
      = f_{2}(g(s)) 
    \]
    che è vera per la \ref{eq:5.1} ed è proprio quello che ci serve.
    L'altro caso è assolutamente duale.
\end{itemize}
Abbiamo dimostrato allora la continuità della funzione $F$:
\[
  \forall b \in PT, \forall g,h \in ST \quad \lambda f \st \cond(b,f \circ h,g)
\]
Per il teorema di Tarski possiede un minimo
punto fisso che è possibile trovare facendo le iterate
successive a partire da $\perp$.
Allora possiamo concludere che:
\[ \calC \llbracket \kw{while} B \kw{do} C \rrbracket = \lfp F \]
E che:
\[ \lfp F = \lub \bigl\{ F^n(\perp ) \bigm| n \in \Nset \bigr\} \]
\end{proof}
