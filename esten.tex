\chapter{Estensioni}

\section{Array} \marginpar{Segalini}

[Breve introduzione\dots Aggiungere nel linguaggio while gli array]

\subsection{Sintassi}

Aggiungiamo alla sintassi del WHILE l'espressione che accede
all'$i$-esimo elemento dell'array:
\begin{align*}
  \AExp \ni E &::= \dots \vbar x(E). \\
\intertext{%
Aggiungiamo inoltre il comando d'assegnamento all'$i$-esimo elemento
dell'array:
}
  \Com \ni C &::= \dots \vbar x(E_1) := E_2.
\end{align*}

\subsection{Semantica informale}

Gli array in questo semplice linguaggio di programmazione (per scelta
di progettazione) sono dinamici: la loro dimensione è illimitata,
ma solo un numero finito di elementi è definito in ogni momento
della computazione.
Gli elementi non precedentemente assegnati dell'array hanno il valore $0$.
Verranno mostrate due
semantiche diverse: in una l'accesso ad una
variabile scalare $x$ con un'espressione della forma $x(E)$
restituisce il valore contenuto in $x$, ignorando quindi $E$.
Nell'altra semantica, l'accesso $x(E)$ trasforma la
variabile scalare $x$ in un array con tutti gli elementi
non definiti eccetto quello nella posizione indicata da $E$,
la quale assumerà il valore contenuto in $x$ prima di tale accesso.

\subsubsection{Semantica formale}

\begin{definizione} \summary{(Array semantici.)}
Un \emph{array} (semantico) è una funzione da interi (indice
dell'array) a interi (contenuto della cella) in cui solo ad un insieme
finito di elementi del dominio corrisponde un numero diverso da $0$.
Formalmente:
\[
  \Lambda
    \defeq
      \Bigl\{\,
        \fund{a}{\Zset}{\Zset}
      \Bigm|
        \bigl\{\, x \in \Zset \bigm| a(x) \neq 0 \,\bigr\} \sseqf \Zset
      \,\Bigr\}.
\]
\end{definizione}

\begin{definizione} \summary{(Insieme degli stati con array.)}
Modifichiamo l'insieme degli store $\Sigma$ per includere gli array tra
le variabili del programma
\[
  \pard{\Sigma}{\Var}{\Zset \union \Lambda}.
\]
\end{definizione}

Semantica di $V(E)$ denotazionale senza conversione scalare-array
\[
  \calE\llbracket V(E) \rrbracket(s) =
  \begin{cases}
    s(V), &\text{se $s(V) \in \Zset$; (V è uno scalare)} \\
    s(V)\bigl(\calE\llbracket E \rrbracket(s)\bigr), &\text{se $s(V)
      \in \Lambda \land \calE\llbracket E \rrbracket(s)\convrg$;} \\
    \divrg, &\text{se $s(V) \in \Lambda \land \calE\llbracket E
      \rrbracket(s)\divrg$;} \\
    \divrg, &\text{se $s(V)\divrg$;}
  \end{cases}
\]

Semantica di $V(E)$ small step su di un array
\[
  \prooftree
  \justifies
  \config{V(n)}{s} \ssarrow \config{s(V)(n)}{s}
  \thickness=0.08em
  \using
  s(V) \in \Lambda
  \endprooftree
\]

Semantica di $V(E)$ (accesso ad array) con conversione scalare-array
data con stile small step. La trasformazione richiede un
cambiamento di stato quindi un effetto collaterale non ammesso nella
semantica denotazionale. Questa semantica trasforma lo scalare in un
array ovunque non definito
\[
  \prooftree
  \justifies
  \config{V(n)}{s} \ssarrow \config{0}{s'}
  \thickness=0.08em
  \using
  s(V) \in \Zset \land s' = \subst{s}{\lambdaop i.0}{V}
  \endprooftree
\]

Questa semantica trasforma lo scalare in un array totalmente
indefinito eccetto per la posizione $n$-ma che sarà inizializzata col
valore contenuto precedentemente in $V$
\[
  \prooftree
  \justifies
  \config{V(n)}{s} \ssarrow \config{s(V)}{s'}
  \thickness=0.08em
  \using
  s(v) \in \Zset \land s' = \subst{s}{a}{V} \land a = \lambdaop i.\begin{cases}
    s(V), &\text{se $i = n$} \\
    0,    &\text{altrimenti}
    \end{cases}
  \endprooftree
\]

Semantica di $V(E) \weq $ small step che permetta la conversione di uno
scalare in un array (assegnamento distruttivo)[problema: viene
lasciato troppo poco spazio]


\[
\prooftree
\justifies
\config{V(h)\ \weq\ k}{s} \ssarrow \config{\kw{skip}}{s'}
\thickness=0.08em
\using
  s' = \begin{cases}
    \subst{s}{a}{V} \land \begin{cases}
      k, &\text{se $i = h$} \\
      0, &\text{se $i \neq h$}
      \end{cases}
    &\text{se $s(V) \in \Zset$} \\
    \subst{s}{a}{V} \land \begin{cases}
      k, &\text{se $i = h$} \\
      a(i), &\text{se $i \neq h$}
      \end{cases}
    &\text{se $s(V) \in \Lambda$}
    \end{cases}
\endprooftree
\]

oppure
\[
\prooftree
\justifies
\config{V(h)\ \weq\ k}{s} \ssarrow \config{\kw{skip}}{s'}
\thickness=0.08em
\using
  s' = \begin{cases}
    \subst{s}{a}{V} \land \begin{cases}
      s(V), &\text{se $i = 0 \land h \neq 0$} \\
      k, &\text{se $i = h$} \\
      0, &\text{se $i \neq h$}
      \end{cases}
    &\text{se $s(V) \in \Zset$} \\
    \subst{s}{a}{V} \land \begin{cases}
      k, &\text{se $i = h$} \\
      a(i), &\text{se $i \neq h$}
      \end{cases}
    &\text{se $s(V) \in \Lambda$}
    \end{cases}
\endprooftree
\]
