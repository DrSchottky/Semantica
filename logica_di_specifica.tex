\subsection{Definizione sintattica}

Definiamo precisamente un linguaggio logico per le
precondizioni e postcondizioni di una logica di Floyd-Hoare.
Sia $x \in \Var \union \Ghost$, dove $\Var$ è l'insieme delle variabili del
programma e $\Ghost$ è un insieme di cosiddette ``variabili fantasma''
(variabili della logica) tale che $\Var \inters \Ghost = \emptyset$.
Sia $c \in C \sslt \Rset$ una generica costante numerica presa dall'insieme
$C$ delle costanti rappresentabili nel linguaggio.
L'insieme delle espressioni aritmetiche della logica, denotato con $\LExp$,
è ora definibile per mezzo di una grammatica in forma BNF del tipo
\[
  \LE \in \LExp ::= x
                \vbar c
                \vbar \LE_1 + \LE_2
                \vbar \sqrt{\LE}
                \vbar \LE^{\LE_2}
                \vbar \LE!
                \vbar \lfloor \LE \rfloor
                \vbar \dots
\]

Sia $\Pred$ l'insieme dei predicati logici definibile con una grammatica
del tipo
\begin{align*}
P \in \Pred &::= \true
            \vbar \false
            \vbar\LE_1 = \LE_2
            \vbar \dots
            \vbar P_1 \land P_2
            \vbar P_1 \lor P_2
            \vbar \neg P \\
            &\vbar \forall x \itc P
            \vbar \exists x \st P
            \vbar P_1 \Rightarrow P_2
            \vbar P_1 \Leftrightarrow P_2 \vbar P_1 \Leftarrow P_2
\end{align*}
dove $x \in\Ghost$.

\subsection{Variabili libere}
In logica matematica e in particolare in un linguaggio del primo ordine si dice che una variabile occorre libera in una formula ben formata se nella formula tale variabile appare al di fuori del dominio di un quantificatore sulla variabile stessa. Una variabile $\Ghost$ può essere libera per questo ce ne interessiamo.
Definiamo due funzioni con lo stesso nome (sovraccaricate) per calcolare le variabili libere in una formula.
Sia $\fund{\FV}{\LExp}{\wp(\Ghost)}$ una funzione per catturare le variabili libere in una espressione della logica.

Definiamola per induzione strutturale :
\begin{align*}
   \FV(x)
      &=
        \begin{cases}
            \emptyset,&\text{se $x  \in \Var$};\\
            \{x\},    &\text{se $x  \in \Ghost$};
        \end{cases} \\
   \FV(c)
      &= \emptyset;\\
   \FV(\LE_1 + \LE_2)
      &= \FV(\LE_1) \union \FV(\LE_2);\\
   \FV(\sqrt{\LE})
      &= \FV(\LE);\\
   \FV(\LE_1^{\LE_2})
      &= \FV(\LE_1) \union \FV(\LE_2);\\
   \FV(\LE!)
      &= \FV(\LE);\\
   \FV(\lfloor \LE \rfloor)
      &= \FV(\LE).
\end{align*}

Sia $\fund{\FV}{\Pred}{\wp(\Ghost)}$ una funzione per catturare le variabili libere in predicati della logica.

Definiamola per induzione strutturale :
\begin{align*}
   \FV(\true)
      &= \emptyset;\\
   \FV(\false)
      &= \emptyset;\\
   \FV(\LE_1 = \LE_2)
      &= \FV(\LE_1) \union \FV(\LE_2);\\
   \FV(P_1 \land P_2)
      &= \FV(P_1) \union \FV(P_2);\\
   \FV(P_1 \lor P_2)
      &= \FV(P_1) \union \FV(P_2);\\
   \FV(\neg P)
      &= \FV(P);\\
   \FV(\forall x \itc P)
      &= \FV(P)\setminus \{x\};\\
   \FV(\exists x \st P)
      &= \FV(P)\setminus \{x\};\\
   \FV(P_1 \Rightarrow P_2)
      &= \FV(P_1) \union \FV(P_2);\\
   \FV(P_1 \Leftrightarrow P_2)
      &= \FV(P_1) \union \FV(P_2);\\
   \FV(P_1 \Leftarrow P_2)
      &= \FV(P_1) \union \FV(P_2).
\end{align*}

\subsection{Definizione semantica}
Per definire la semantica di un tale linguaggio logico abbiamo bisogno
di formalizzare l'operazione di sostituzione sintattica di termini
al posto di variabili.

\begin{definizione} \summary{(Sostituzione per LExp.)}
Sia $x \in \Var \union \Ghost$ una variabile e siano $\LE_0, LE \in \LExp$
due espressioni.
L'espressione $\LE_0\substt{\LE}{x}$ è un elemento di $\LExp$ definito
per induzione strutturale su $\LE_0$ come segue:
\begin{align*}
   x_0\substt{\LE}{x}
    &=
      \begin{cases}
        \LE, &\text{se $x_0 = x$;} \\
        x_0, &\text{se $x_0 \neq x$;}
      \end{cases} \\
   c\substt{\LE}{x}
    &= c;\\
  (\LE_1 + \LE_2)\substt{\LE}{x}
     &= \bigl(\LE_1\substt{\LE}{x}\bigr) + \bigl(\LE_2\substt{\LE}{x}\bigr);\\
  \sqrt{\LE_1}\substt{\LE}{x}
     &= \sqrt{{\LE_1}\substt{\LE}{x}};\\
  \LE_1^{\LE_2}\substt{\LE}{x}
     &= \LE_1\substt{\LE}{x}^{\LE_2\substt{\LE}{x}};\\
  {\LE_1}!\substt{\LE}{x}
     &= {{\LE_1}\substt{\LE}{x}}!;\\
  \lfloor \LE_1 \rfloor\substt{\LE}{x}
     &= \bigl\lfloor \LE_1\substt{\LE}{x} \bigr\rfloor.\\
\end{align*}
La definizione si estende in modo ovvio ad ogni altro operatore presente
nella sintassi delle espressioni.
\end{definizione}

\begin{definizione} \summary{(Sostituzione per Pred.)}
Sia $x \in \Var \union \Ghost$ una variabile, $\LE \in \LExp$ un'espressione
e $P \in \Pred$ un predicato.
L'espressione $P\substt{\LE}{x}$ è un elemento di $\Pred$ definito
per induzione strutturale su $P$ come segue:
\begin{align*}
  \true\substt{\LE}{x}
    &= \true;\\
  \false\substt{\LE}{x}
    &= \false;\\
  (\LE_1 = \LE_2)\substt{\LE}{x}
    &= \bigl(\LE_1\substt{\LE}{x}\bigr) = \bigl(\LE_2\substt{\LE}{x}\bigr);\\
  (P_1 \land P_2)\substt{\LE}{x}
    &= \bigl(\LE_1\substt{\LE}{x}\bigr) \land \bigl(\LE_2\substt{\LE}{x}\bigr);\\
  (P_1 \lor P_2)\substt{\LE}{x}
    &= \bigl(\LE_1\substt{\LE}{x}\bigr) \lor \bigl(\LE_2\substt{\LE}{x}\bigr);\\
  (\neg P)\substt{\LE}{x}
    &= \neg \bigl(P \substt{\LE}{x}\bigr);\\
  (\forall y\itc P)\substt{\LE}{x}
    &= \forall z\itc \bigl(P \substt{z}{y}\bigr)\substt{\LE}{x} \text{ con: $z\notin\FV(\LE), z\notin\FV(P), z\neq x$};\\
  (\exists  y\st P)\substt{\LE}{x}
    &= \exists z\st \bigl(P \substt{z}{y}\bigr)\substt{\LE}{x} \text{ con: $z\notin\FV(\LE), z\notin\FV(P), z\neq x$};\\
  (P_1 \Rightarrow P_2)\substt{\LE}{x}
    &= \bigl(P_1\substt{\LE}{x}\bigr) \Rightarrow \bigl(P_2\substt{\LE}{x}\bigr);\\
  (P_1 \Leftrightarrow P_2)\substt{\LE}{x}
    &= \bigl(P_1\substt{\LE}{x}\bigr) \Leftrightarrow \bigl(P_2\substt{\LE}{x}\bigr);\\
  (P_1 \Leftarrow P_2)\substt{\LE}{x}
    &= \bigl(P_1\substt{\LE}{x}\bigr) \Leftarrow \bigl(P_2\substt{\LE}{x}\bigr).
\end{align*}
\end{definizione}

\subsection{Valutazione semantica di LExp}
$\Sigma$ rappresenta lo store utile in quanto nelle espressioni possono comparire variabili del programma, mentre $\Gamma$ e' l'ambiente delle variabili $\Ghost$ definita come $\fund{\Gamma}{\Ghost}{\Zset}$. Funzione di valutazione semantica delle espressioni:
\[
   \fund{\llbracket \cdot \rrbracket ^\LExp}{\LExp}{((\Sigma \times \Gamma) \rightarrow \Zset)}
\]
Diamo una definizione per induzione strutturale su ogni espressione:
\begin{align*}
   \llbracket x \rrbracket(s,t)
      &=
        \begin{cases}
                 s(x), &\text{se $x \in \Var$};\\
                 t(x), &\text{se $x \in \Ghost$};
        \end{cases}\\
   \llbracket  c \rrbracket(s,t)
     &=  c;\\
   \llbracket \LE_1 + \LE_2 \rrbracket(s,t)
     &= \llbracket \LE_1 \rrbracket(s,t) + \llbracket \LE_2 \rrbracket(s,t);\\
   \llbracket \sqrt{\LE} \rrbracket(s,t)
     &= \sqrt{\llbracket \LE \rrbracket}(s,t);\\
   \llbracket \LE^{\LE_2} \rrbracket(s,t)
     &= \llbracket \LE \rrbracket^{\llbracket \LE_2 \rrbracket}(s,t);\\
   \llbracket \LE! \rrbracket(s,t)
     &= \llbracket \LE \rrbracket!(s,t);\\
   \llbracket \lfloor \LE \rfloor \rrbracket(s,t)
     &= \bigl \lfloor \llbracket \LE \rrbracket \bigr \rfloor(s,t).
\end{align*}

\subsection{Valutazione semantica di Pred}
Funzione di valutazione semantica dei predicati:
\[
   \fund{\llbracket \cdot \rrbracket ^{\Pred}}{\Pred}{((\Sigma \times \Gamma) \rightarrow \{\ttv,\ffv\})}
\]
Usando ancora l'induzione strutturale su ogni predicato:
\begin{align*}
   \llbracket \true \rrbracket(s,t)
      &= \ttv;\\
   \llbracket \false \rrbracket(s,t)
      &= \ffv;\\
   \llbracket \LE_1 = \LE_2\rrbracket(s,t)
      &=
        \begin{cases}
                \ttv, &\text{se $\llbracket\LE_1\rrbracket(s,t) = \llbracket \LE_2 \rrbracket(s,t)$};\\
                \ffv, &\text{altrimenti};
        \end{cases}\\
    \llbracket P_1 \land P_2\rrbracket(s,t)
      &=
        \begin{cases}
                \ttv, &\text{se $\llbracket P_1\rrbracket(s,t) = \llbracket P_2\rrbracket(s,t) = \true$};\\
                \ffv, &\text{altrimenti};
        \end{cases}\\
    \llbracket P_1 \lor P_2\rrbracket(s,t)
      &=
        \begin{cases}
                \ffv, &\text{se $\llbracket P_1\rrbracket(s,t) = \llbracket P_2\rrbracket(s,t) = \false$};\\
                \ttv, &\text{altrimenti};
        \end{cases} \\
    \llbracket \neg P\rrbracket(s,t)
       &=
        \begin{cases}
                \ttv,&\text{se $\llbracket P\rrbracket(s,t) = \ffv$};\\
                \ffv,&\text{se $\llbracket P\rrbracket(s,t) = \ttv$};
        \end{cases}
\end{align*}
Poniamo attenzione ai due casi particolari:
\begin{align*}
   \llbracket\forall x \itc P\rrbracket(s,t)
      &=
        \begin{cases}
                \ttv, &\text{se $\forall k\in\Zset\itc(\llbracket P\rrbracket(s,t\substt{k}{x}) = \ttv$});\\
                \ffv, &\text{se $\exists k\in\Zset\st(\llbracket P\rrbracket(s,t\substt{k}{x}) = \ffv$});
        \end{cases}\\
   \llbracket \exists x \st P\rrbracket(s,t)
      &=
        \begin{cases}
                \ttv,  &\text{se $\exists k\in \Zset\st(\llbracket P\rrbracket(s,t\substt{k}{x}) = \ttv$});\\
                \ffv,  &\text{se $\forall k\in \Zset\itc(\llbracket P\rrbracket(s,t\substt{k}{x}) = \ffv$});
        \end{cases}
\end{align*}
Dove:
\begin{align*}
   \forall x,y\in\Ghost\itc\forall t \in\Gamma\itc\forall k\in\Zset \itc t\substt{k}{x}(y)
      &=
        \begin{cases}
                 k,   &\text{se $x = y$};\\
                 t(y),&\text{se $x  \neq  y$};
        \end{cases}
\end{align*}
\begin{align*}
    \llbracket P_1 \Rightarrow P_2 \rrbracket(s,t)
       &=
        \begin{cases}
            \ffv, &\text{se $\llbracket P_1\rrbracket(s,t) = \true \land \llbracket P_2\rrbracket(s,t) = \false$};\\
            \ttv, &\text{altrimenti};
        \end{cases}\\
    \llbracket P_1 \Leftrightarrow P_2\rrbracket(s,t)
       &=
        \begin{cases}
            \ttv,&\text{se $\llbracket P_1\rrbracket(s,t) = \llbracket P_2\rrbracket(s,t) = \true$}\\
                 &\text{$\lor\llbracket P_1\rrbracket(s,t) = \llbracket P_2 \rrbracket(s,t) = \false$};\\
            \ffv, &\text{altrimenti};
        \end{cases}\\
   \llbracket P_1 \Leftarrow P_2\rrbracket(s,t)
      &=
        \begin{cases}
            \ffv,&\text{se $\llbracket P_1\rrbracket(s,t) = \false \land \llbracket P_2\rrbracket(s,t) = \true$};\\
            \ttv,&\text{altrimenti}.
   \end{cases}
\end{align*}
\subsection{Verità di una tripla di Floyd-Hoare}
Ora abbiamo tutti gli elementi per definire quando una tripla di Hoare è vera.
\[
   \llbracket \{P\}C\{Q\} \rrbracket = \ttv;
\]
\textbf{Caso semplice: }Supponiamo di non avere variabili $\Ghost$:
\[
   \FV(P) \union \FV(Q)= \emptyset;
\]
Quindi :
\begin{align*}
   \llbracket \{P\} C\{Q\} \rrbracket 
      = \ttv \Leftrightarrow (\forall s,s'\in \Sigma \itc(
      &\llbracket P \rrbracket( s,\emptyset) = \ttv\land <C,s>\rightarrow ^*<\mathrm{skip},s'>)\\
      \Rightarrow&\llbracket Q \rrbracket(s',\emptyset)=\ttv);
\end{align*}
\textbf{Caso Completo: }Caso in cui sono effettivamente presenti variabili $\Ghost$, ma prima riflettiamo.
Nelle triple di Hoare se ci sono variabili non quantificate, esse vengono universalmente quantificate (con un $\forall$) in maniera implicita.
\[
   \FV(P) \union \FV(Q) \neq \emptyset;
\]
Quindi :
\begin{align*}
    \llbracket \{P\} C\{Q\} \rrbracket 
       = \ttv \Leftrightarrow \forall t \in \Gamma_{\FV(P)\union \FV(Q)}\itc
       &(\forall  s,s'\in \Sigma\itc(\llbracket P \rrbracket(s,t) = \ttv\\
       &\land <C,s>\rightarrow ^*<\mathrm{skip},s'>)\\
       &\Rightarrow\llbracket Q \rrbracket(s',t)=\ttv);
\end{align*}
Dove:
\[
   \forall v \subset \Ghost,\Gamma_{v} =\{t \in \Gamma \text{ t.c; $\dom(t) = v$\}}.
\]
\subsection{Correttezza della logica di Floyd-Hoare}
Se la tripla di Hoare ha dimostrazione, allora essa è vera.
\[
   \forall P,Q \in \Pred \itc \forall C \in \Com : \vdash\{P\}C\{Q\} \Rightarrow \llbracket \{P\}C\{Q\}\rrbracket;
\]
Si dimostra per induzione strutturale sull'albero che dimostra \{P\}C\{Q\}:
\textbf{Skip}
\[
 \prooftree
 \justifies
    \{P\}\mathrm{skip}\{P\}
 \thickness=0.08em
 \shiftright 2em
 \using
 \endprooftree
\]
\begin{align*}
   \llbracket \{P\}\mathrm{skip}\{P\} \rrbracket \Leftrightarrow \forall t \in \Gamma_{\FV(P)}\itc
      &\forall s,s'\in \Sigma \itc(\llbracket P \rrbracket(s,t) = \ttv\\
      &\land <\mathrm{skip},s>\rightarrow ^*<\mathrm{skip},s'>)\\
      &\Rightarrow\llbracket P \rrbracket(s',t)=\ttv);
\end{align*}

\begin{proof}
Dato che la premessa è vera abbiamo che $s=s'$, dunque:
\[
   \llbracket P \rrbracket(s,t)=\ttv =\llbracket P \rrbracket(s',t).
\]
\end{proof}
\textbf{Assegnamento}
\[
 \prooftree
 \justifies
    \{Q\substt{\LE}{x}\}x:=\LE\{Q\}
 \thickness=0.08em
 \shiftright 2em
 \using
 \endprooftree
\]
\begin{align*}
   \llbracket \{Q\substt{\LE}{x}\}x:=\LE\{Q\} \rrbracket \Leftrightarrow
      &\forall t \in \Gamma_{\FV(\LE)\union \FV(Q)}\itc\forall s,s'\in \Sigma \itc\\
      &(\llbracket Q \rrbracket\substt{\LE}{x}(s,t) = \ttv\\
      &\land <x:=\LE,s>\rightarrow ^*<\mathrm{skip},s'>)\\
      &\Rightarrow\llbracket Q \rrbracket(s',t)=\ttv);
\end{align*}
Questo grazie al \textbf{Lemma}:
\begin{align*}
   \forall k \in \Nset \itc
      &(<x:=\LE,s> \rightarrow ^k<\mathrm{skip},s'>\\
      &\Rightarrow \exists n \in \Zset\st <\LE,s>\rightarrow ^{k-1}<n,s>\land s'=s\substt{n}{x});
\end{align*}
\begin{proof}
\text{Con: $k = 0$ è banalmente vera poiché l'antecedente è falso.}\\
\text{Con: $k = 1$ abbiamo:}
\[
   <x:=\LE,s>\rightarrow ^1<\mathrm{skip},s'>;
\]
\text{ma allora $\LE \in \Zset$ e $s'=s\substt{n}{x},$ quindi $\exists n=\LE$ tali che:}
\[
   <\LE,s>\rightarrow ^0<\LE,s> \equiv <n,s>.
\]
Per definizione di $\rightarrow ^0$ chiusura riflessiva.\\
\textit{Passo induttivo}\\
\text{Con: $k = h+1$}
\[
   <x:=\LE,s>\rightarrow ^{h+1}<\mathrm{skip},s'>;
\]
Allora si può ricondurre ad $h+1$ passi per poi applicare l'ipotesi induttiva:
\[
   <x:=\LE,s>\rightarrow ^1<x:=\LE',s>;
\]
Ora:
\[
   <x:=\LE',s>\rightarrow ^h<\mathrm{skip},s'>;
\]
per ipotesi induttiva si ha che:
\[
   \exists n \in\Zset\itc <\LE',s>\rightarrow ^{h-1}<n,s>;
\]
e inoltre:
\[
   s'=s\substt{n}{x};
\]
Allora aggiungendo l'ultimo passo:
\[
   <x:=\LE,s>\rightarrow ^1<x:=\LE',s>\rightarrow ^h<\mathrm{skip},s'>;
\]
\[
   <\LE,s>\rightarrow ^1<\LE',s>\rightarrow ^{h-1}<n,s'>;
\]
Allora:
\[
   <\LE,s>\rightarrow ^h<\mathrm{skip},s'>.
\]
\end{proof}
\textbf{Composizione Sequenziale}
\[
\prooftree
   \{P\} C_1\{Q\}
   \hspace{1mm}
   \{Q\} C_2\{R\}
\justifies
   \{P\}C_1;C_2\{R\}
\thickness=0.08em
\shiftright 0em
\using
	CS
\endprooftree
\]
\begin{align*}
   \llbracket \{P\} C_1;C_2\{R\} \rrbracket \Leftrightarrow \forall t \in \Gamma_{\FV(P)\union\FV(R)}\itc
      &(\forall s,s'\in \Sigma \itc(\llbracket P \rrbracket(s,t) = \ttv\\
      &\land <C_1;C_2,s>\rightarrow ^*<\mathrm{skip},s'>)\\
      &\Rightarrow\llbracket R \rrbracket(s',t)=\ttv);
\end{align*}
\begin{align*}
   \llbracket \{P\}C_1\{Q\} \rrbracket \land \llbracket \{Q\}C_2\{R\} \rrbracket \Leftrightarrow
      &\forall t \in \Gamma_{\FV(P)\union\FV(R)\union\FV(Q)}\itc\\
      &\forall s,s'\in \Sigma \itc(\llbracket P \rrbracket(s,t) = \ttv\\
      &\land <C_1,s>\rightarrow ^*<\mathrm{skip},s'>\\
      &\land \llbracket Q\rrbracket(s',t)=\ttv \\
      &\land <C_2,s'>\rightarrow ^*<\mathrm{skip},s''>)\\
      &\Rightarrow \llbracket R \rrbracket(s'',t)=\ttv;
\end{align*}
Questo grazie al \textbf{Lemma}:
\begin{align*}
   <C_1;C_2,s>\rightarrow ^k<\mathrm{skip},s'>\Rightarrow\forall k_1,k_2 \in\Nset 
   &\itc<C_1,s>\rightarrow ^{k_1}<\mathrm{skip},s'> \\
   &\land <C_2,s'>\rightarrow ^{k_2}<\mathrm{skip},s''>.
\end{align*}
\begin{proof}

\end{proof}