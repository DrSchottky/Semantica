\chapter{Relazioni tra le semantiche}

\subsection{Esercizio 1} \marginpar{Mancino}
Aggiungere al linguaggio \emph{While} visto a lezione l'espressione:
$$ Exp \ni E ::= \dots \; | \; B \; ? \; E_2 \; : \; E_3 $$
definendone la semantica operazionale Big Step, Small Step e denotazionale.

\begin{proof}[Svolgimento]
Di seguito illustriamo le regole e gli assiomi in semantica Small Step:
$$ \prooftree
		\langle B,s \rangle \; \rightarrow \; \langle B', s' \rangle
      	\justifies
      		\langle B \; ? \; E_2 \; : E_3, s \rangle \; \rightarrow \; \langle B' \; ? \; E_2 \; : E_3, s' \rangle
	\thickness=0.08em
	\endprooftree
$$

$$ \prooftree
      	\justifies
      		\langle true \; ? \; E_2 \; : E_3, s \rangle \; \rightarrow \; \langle E_2, s' \rangle
	\thickness=0.08em
	\endprooftree
$$

$$ \prooftree
      	\justifies
      		\langle false \; ? \; E_2 \; : E_3, s \rangle \; \rightarrow \; \langle E_3, s' \rangle
	\thickness=0.08em
	\endprooftree
$$

Di seguito illustriamo le regole e gli assiomi in semantica Big Step:
$$ \prooftree
		\langle B,s \rangle \Downarrow \langle true, s' \rangle \; \;
		\langle E_2,s' \rangle \Downarrow \langle n, s'' \rangle
      	\justifies
      		\langle B \; ? \; E_2 \; : E_3, s \rangle \Downarrow \langle n, s'' \rangle
	\thickness=0.08em
	\endprooftree
$$

$$ \prooftree
		\langle B,s \rangle \Downarrow \langle false, s' \rangle \; \;
		\langle E_3,s' \rangle \Downarrow \langle n, s'' \rangle
      	\justifies
      		\langle B \; ? \; E_2 \; : E_3, s \rangle \Downarrow \langle n, s'' \rangle
	\thickness=0.08em
	\endprooftree
$$

Di seguito illustriamo la definizione dell'espressione in semantica denotazionale:
$$
\llbracket B \; ? \; E_2 \; : \; E_3 \rrbracket (s) \; =
\begin{cases}
	\varepsilon \llbracket E_2 \rrbracket (s) & se \; \emph{B} \llbracket B \rrbracket (s) = tt \\
	\varepsilon \llbracket E_3 \rrbracket (s) & se \; \emph{B} \llbracket B \rrbracket (s) = ff \\
	\bot & altrimenti
\end{cases}
$$
\end{proof}

\subsection{Esercizio 2} \marginpar{Segalini}
Aggiungere nel linguaggio while gli array:

\subsubsection{Sintassi}
Aggiungiamo alla sintassi del while l'espressione che accede
all'$i$-esimo elemento dell'array
$$V \in \Var = \{ v_0, v_1, \ldots \}$$
$$Exp \ni E ::= \dots \vbar V(E)$$
Aggiungiamo il comando d'assegnamento all'$i$-esimo elemento
dell'array
$$Com \ni C ::= \dots \vbar V(E_1) := E_2$$

\subsubsection{Semantica Informale}
Gli array in questo semplice linguaggio di programmazione (per scelta
di progettazione) saranno dinamici: la loro dimensione sarà illimitata
e solo un numero finito di elementi sarà definito. Gli elementi non
definiti dell'array assumeranno valore nullo. Verranno mostrate due
semantiche diverse: in una l'accesso ad una
variabile scalare come se fosse un array restituisce il valore
contenuto nella stessa. Nell'altra semantica, l'accesso trasforma la
variabile in un array con tutti gli elementi
non definiti eccetto per quello nella posizione indicata che assumerà
il valore contenuto nella variabile quando era ancora scalare.

\subsubsection{Semantica Formale}
\begin{definizione} \summary{(Array in while.)}
Un array è una funzione da interi (indice dell'array) a interi
(contenuto della cella) in cui ad ogni istante finito, è finito il
numero di elementi definiti (diversi dal valore nullo)
\[
  \Lambda \defeq \Biggl\{\,
  \pard{a}{\Zset}{\Zset} \Biggm| \Bigm|\bigl\{\, x \in \Zset
  \bigm| a(x) \neq 0 \,\bigr\}\Bigm| < \aleph_0  
  \,\Biggr\}.
\] 
\end{definizione}

\begin{definizione} \summary{(Insieme degli stati con array.)}
Modifichiamo l'insieme degli store $\Sigma$ per includere gli array tra
le variabili del programma
\[
  \pard{\Sigma}{\Var}{\Zset \union \Lambda}.
\]
\end{definizione}

Semantica di $V(E)$ denotazionale senza conversione scalare-array
\[
  \calE\llbracket V(E) \rrbracket(s) =
  \begin{cases}   
    s(V), &\text{se $s(V) \in \Zset$; (V è uno scalare)} \\
    s(V)\bigl(\calE\llbracket E \rrbracket(s)\bigr), &\text{se $s(V)
      \in \Lambda \land \calE\llbracket E \rrbracket(s)\convrg$;} \\
    \divrg, &\text{se $s(V) \in \Lambda \land \calE\llbracket E
      \rrbracket(s)\divrg$;} \\
    \divrg, &\text{se $s(V)\divrg$;}
  \end{cases}
\]

Semantica di $V(E)$ small step su di un array
\[
  \prooftree           
  \justifies             
  \config{V(n)}{s} \ssarrow \config{s(V)(n)}{s}      
  \thickness=0.08em
  \using
  s(V) \in \Lambda
  \endprooftree
\]

Semantica di $V(E)$ (accesso ad array) con conversione scalare-array
data con stile small step. La trasformazione richiede un
cambiamento di stato quindi un effetto collaterale non ammesso nella
semantica denotazionale. Questa semantica trasforma lo scalare in un
array ovunque non definito
\[
  \prooftree           
  \justifies             
  \config{V(n)}{s} \ssarrow \config{0}{s'}      
  \thickness=0.08em
  \using
  s(V) \in \Zset \land s' = \subst{s}{\lambdaop i.0}{V} 
  \endprooftree
\]

Questa semantica trasforma lo scalare in un array totalmente
indefinito eccetto per la posizione $n$-ma che sarà inizializzata col
valore contenuto precedentemente in $V$
\[
  \prooftree           
  \justifies             
  \config{V(n)}{s} \ssarrow \config{s(V)}{s'}      
  \thickness=0.08em
  \using
  s(v) \in \Zset \land s' = \subst{s}{a}{V} \land a = \lambdaop i.\begin{cases}
    s(V), &\text{se $i = n$} \\
    0,    &\text{altrimenti}
    \end{cases}
  \endprooftree
\]

Semantica di $V(E) \weq $ small step che permetta la conversione di uno
scalare in un array (assegnamento distruttivo)[problema: viene
lasciato troppo poco spazio]


\[
\prooftree           
\justifies             
\config{V(h)\ \weq\ k}{s} \ssarrow \config{\kw{skip}}{s'}      
\thickness=0.08em
\using
  s' = \begin{cases}
    \subst{s}{a}{V} \land \begin{cases}
      k, &\text{se $i = h$} \\
      0, &\text{se $i \neq h$}			
      \end{cases}
    &\text{se $s(V) \in \Zset$} \\
    \subst{s}{a}{V} \land \begin{cases}
      k, &\text{se $i = h$} \\
      a(i), &\text{se $i \neq h$}							
      \end{cases}	
    &\text{se $s(V) \in \Lambda$}
    \end{cases}
\endprooftree
\]

oppure
\[
\prooftree           
\justifies             
\config{V(h)\ \weq\ k}{s} \ssarrow \config{\kw{skip}}{s'}      
\thickness=0.08em
\using
  s' = \begin{cases}
    \subst{s}{a}{V} \land \begin{cases}
      s(V), &\text{se $i = 0 \land h \neq 0$} \\
      k, &\text{se $i = h$} \\
      0, &\text{se $i \neq h$}			
      \end{cases}
    &\text{se $s(V) \in \Zset$} \\
    \subst{s}{a}{V} \land \begin{cases}
      k, &\text{se $i = h$} \\
      a(i), &\text{se $i \neq h$}							
      \end{cases}
    &\text{se $s(V) \in \Lambda$}
    \end{cases}
\endprooftree
\]

