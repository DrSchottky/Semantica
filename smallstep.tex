\chapter{Semantica operazionale ``small step''}
\marginpar{Marano}
In questo capitolo parleremo della semantica operazionale "small step", una semantica che descrive formalmente dopo ogni piccolo passo di calcolo che comando
viene eseguito e come viene modificato lo store. Per fare ciò sfrutta assiomi e regole che hanno la stessa forma di quelle viste nel capitolo precedente

$$
\prooftree
premessa_1
\cdots
premessa_k
\justifies
conclusioni
\using
(nome \; regola)
\endprooftree
$$

\section{Introduzione}\marginpar{Marano}
Se quindi abbiamo un linguaggio con la seguente sintassi
$$ Exp \ni E ::= n \bigm| (E+E) \bigm| \cdots $$
dove $n$ si espande nei naturali $1, 2, \dots$ (nei puntini di sospensione si può inserire qualsiasi espressione).
Allora una possibile semantica small step è:

\begin{align*}
  \prooftree
  \justifies
  n \rightarrow n
  \using
  (S-NUM)
  \endprooftree
  &&
  \prooftree
  E_1 \rightarrow E_1'
  \justifies
  (E_1 + E_2) \rightarrow (E_1' + E_2)
  \using
  (S-LEFT)
  \endprooftree
\\
\\
  \prooftree
  E_2 \rightarrow E_2'
  \justifies
  (E_1 + E_2) \rightarrow (E_1 + E_2')
  \using
  (S-RIGHT)
  \endprooftree
  &&
  \prooftree
  \justifies
  (1 + 2) \rightarrow 3
  \using
  (S-ADD)
  \endprooftree
\end{align*}

L'operatore $\rightarrow$ quindi rappresenta a tutti gli effetti un passo di computazione.
Con questa semantica abbiamo lo stesso potere espressivo della semantica Big step ma,
essendo più verbosa, da più informazione sulla sequenzialità e sui "risultati intermedi".
Vediamo un esempio di dimostrazione:

\begin{align*}
\prooftree
	\prooftree
   		\justifies
   			(1+2) \rightarrow 3
   		\using
   			(S-ADD)
	\endprooftree
\justifies
       	((1+2)+(3+4)) \rightarrow (3+(3+4))
\using
	(S-ADD)
\endprooftree
\\
\\
\prooftree
	\prooftree
   		\justifies
   			(3+4) \rightarrow 7
   		\using
   			(S-ADD)
	\endprooftree
\justifies
       	(3+(3+4)) \rightarrow (3+7)
\using
	(S-ADD)
\endprooftree
\\
\\
\prooftree
	\justifies
		(3+7) \rightarrow 10
	\using
		(S-ADD)
\endprooftree
\end{align*}

Possiamo subito osservare che differentemente dalla semantica Big Step
nella semantica Small Step si usano tanti alberi di dimostrazione più piccoli per dimostrare
ogni asserzione. 

\section{Determinatezza della semantica Small Step}\marginpar{Marano}
[Da aggiungere determinatezza...]

\section{Semantica Small Step per While}\marginpar{Marano}
Diamo ora una semantica al linguaggio While tramite la small step, dovremo
perciò valutare non più una singola espressione ma una coppia formata da
comando e stato. Per ora tralasciamo la possibilità di effetti collaterali.
$$
\langle C,s \rangle \rightarrow \langle C',s' \rangle
$$
Indichiamo perciò con E la generica espressione, con C il generico comando 
e con s il generico stato:
\begin{align*}
(S-SKIP)
&&
\prooftree
   \justifies
   		\langle skip, s \rangle \rightarrow s
\endprooftree
\\
(S-EXP.NUM)
&&
\prooftree
   \justifies
   \langle x, s \rangle \rightarrow \langle n, s \rangle
   \using
   s(x) = n 
\endprooftree
\end{align*}

Osserviamo che il comando skip e la lettura in memoria non modificano lo stato attuale.

\begin{align*}
(S-EXP.LEFT)
&&
\prooftree
	\langle E_1, s \rangle \rightarrow \langle E_1', s \rangle
   \justifies
	\langle (E_1 + E_2), s \rangle \rightarrow \langle (E_1' + E_2), s \rangle
\endprooftree
\\
\\
(S-EXP.RIGHT)
&&
\prooftree
	\langle E_2, s \rangle \rightarrow \langle E_2', s \rangle
   \justifies
	\langle (E_1 + E_2), s \rangle \rightarrow \langle (E_1 + E_2'), s \rangle
\endprooftree
\\
\\
(S-ADD)
&&
\prooftree
   \justifies
   \langle (n_1 + n_2), s \rangle \rightarrow \langle n_3, s \rangle
   \using
   n_3 = n_1 + n_2
\endprooftree
\\
\\
(S-ASS.EXP)
&&
\prooftree
	\langle E, s \rangle \rightarrow \langle E', s \rangle
   \justifies
   	\langle x:= E, s \rangle \rightarrow \langle x:= E', s \rangle
\endprooftree
\\
\\
(S-ASS.NUM)
&&
\prooftree
   \justifies
   	\langle x:= n, s \rangle \rightarrow \langle skip, s[x \rightarrow n] \rangle
\endprooftree
\\
\\
(S-SEQ.LEFT)
&&
\prooftree
	\langle C_1, s \rangle \rightarrow \langle C_1', s' \rangle
   \justifies
   	\langle C_1 ; C_2, s \rangle \rightarrow \langle C_1' ; C_2, s' \rangle
\endprooftree
\\
\\
(S-SEQ.SKIP)
&&
\prooftree
   \justifies
   	\langle skip ; C_2, s \rangle \rightarrow \langle C_2, s' \rangle
\endprooftree
\\
\\
(S-COND.BOOL)
&&
\prooftree
	\langle B, s \rangle \rightarrow \langle B', s \rangle
   \justifies
   	\langle if B then C_1 else C_2, s \rangle \rightarrow \langle if B' then C_1 else C_2, s \rangle
\endprooftree
\\
\\
(S-COND.TRUE)
&&
\prooftree
   \justifies
   	\langle if true then C_1 else C_2, s \rangle \rightarrow \langle C_1, s \rangle
\endprooftree
\\
\\
(S-COND.FALSE)
&&
\prooftree
   \justifies
   	\langle if false then C_1 else C_2, s \rangle \rightarrow \langle C_2, s \rangle
\endprooftree
\\
\\
(S-WHILE.BOOL)
&&
\prooftree
	\langle B, s \rangle \rightarrow \langle B', s \rangle
   \justifies
   	\langle while B do C, s \rangle \rightarrow \langle while B do C, s \rangle
\endprooftree
\\
\\
(S-WHILE.FALSE)
&&
\prooftree
   \justifies
   	\langle while false do C, s \rangle \rightarrow \langle skip, s \rangle
\endprooftree
\\
\\
(S-WHILE)
&&
\prooftree
   \justifies
   	\langle while B do C, s \rangle \rightarrow \langle if B then (C ; while B do C) else skip, s \rangle
\endprooftree
\\
\end{align*}
[Da aggiungere And e Or logici e circuitati e correggere impaginazione]



